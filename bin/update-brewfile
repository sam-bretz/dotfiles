#!/bin/bash

# update-brewfile - Smart Brewfile synchronization script
# Updates existing Brewfile with currently installed packages while preserving comments and organization

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Default Brewfile location
BREWFILE="${HOMEBREW_BUNDLE_FILE:-${HOME}/.dotfiles/brew/Brewfile}"
BACKUP_DIR="${HOME}/.dotfiles/backup"

# Usage information
usage() {
    cat << EOF
${CYAN}update-brewfile${NC} - Smart Brewfile synchronization

${YELLOW}USAGE:${NC}
    update-brewfile [OPTIONS]

${YELLOW}OPTIONS:${NC}
    -f, --file FILE     Specify Brewfile location (default: ~/.dotfiles/brew/Brewfile)
    -b, --backup        Create backup before updating (default: true)
    -n, --dry-run       Show what would be changed without modifying files
    -v, --verbose       Show detailed output
    -h, --help          Show this help message

${YELLOW}EXAMPLES:${NC}
    update-brewfile                    # Update default Brewfile
    update-brewfile --dry-run          # Preview changes
    update-brewfile -f ./Brewfile      # Update specific file
    update-brewfile --verbose          # Show detailed output

${YELLOW}FEATURES:${NC}
    • Preserves existing comments and organization
    • Creates timestamped backups
    • Handles taps, formulae, casks, and Mac App Store apps
    • Smart merging of existing and new entries
    • Dry-run mode for safe testing
EOF
}

# Logging functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1" >&2; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1" >&2; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# Parse command line arguments
DRY_RUN=false
VERBOSE=false
CREATE_BACKUP=true

while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--file)
            BREWFILE="$2"
            shift 2
            ;;
        -b|--backup)
            CREATE_BACKUP=true
            shift
            ;;
        --no-backup)
            CREATE_BACKUP=false
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Verbose logging
verbose_log() {
    if [[ "$VERBOSE" == "true" ]]; then
        log_info "$1"
    fi
}

# Create backup if requested
create_backup() {
    if [[ "$CREATE_BACKUP" == "true" && -f "$BREWFILE" ]]; then
        local backup_file="${BACKUP_DIR}/Brewfile.$(date +%Y%m%d_%H%M%S)"
        mkdir -p "$BACKUP_DIR"
        cp "$BREWFILE" "$backup_file"
        log_success "Backup created: $backup_file"
    fi
}

# Generate current system state
generate_current_brewfile() {
    local temp_file=$(mktemp)
    
    verbose_log "Generating current system state..."
    
    # Use brew bundle dump to get current state
    if brew bundle dump --force --describe --file="$temp_file" 2>/dev/null; then
        echo "$temp_file"
    else
        log_error "Failed to generate current Brewfile"
        rm -f "$temp_file"
        exit 1
    fi
}

# Extract sections from Brewfile
extract_section() {
    local file="$1"
    local section="$2"
    
    case "$section" in
        "taps")
            grep '^tap ' "$file" 2>/dev/null || true
            ;;
        "brews")
            grep '^brew ' "$file" 2>/dev/null || true
            ;;
        "casks")
            grep '^cask ' "$file" 2>/dev/null || true
            ;;
        "mas")
            grep '^mas ' "$file" 2>/dev/null || true
            ;;
        "whalebrew")
            grep '^whalebrew ' "$file" 2>/dev/null || true
            ;;
        "vscode")
            grep '^vscode ' "$file" 2>/dev/null || true
            ;;
    esac
}

# Merge sections intelligently
merge_sections() {
    local existing_file="$1"
    local current_file="$2"
    local output_file="$3"
    
    verbose_log "Merging existing and current configurations..."
    
    # Start with header if it exists
    if [[ -f "$existing_file" ]]; then
        # Extract header comments (everything before first tap/brew/cask line)
        sed '/^[[:space:]]*\(tap\|brew\|cask\|mas\|whalebrew\|vscode\)/,$d' "$existing_file" > "$output_file"
    else
        # Create basic header
        cat > "$output_file" << EOF
# Homebrew Bundle File
# Generated by update-brewfile on $(date)
# 
# Install with: brew bundle install
# Update with: update-brewfile

EOF
    fi
    
    # Process each section
    for section in taps brews casks mas whalebrew vscode; do
        verbose_log "Processing $section section..."
        
        local current_section=$(extract_section "$current_file" "$section")
        if [[ -n "$current_section" ]]; then
            echo "" >> "$output_file"
            
            # Add section header based on type
            case "$section" in
                "taps") echo "# Taps" >> "$output_file" ;;
                "brews") echo "# Formulae" >> "$output_file" ;;
                "casks") echo "# Casks" >> "$output_file" ;;
                "mas") echo "# Mac App Store" >> "$output_file" ;;
                "whalebrew") echo "# Whalebrew" >> "$output_file" ;;
                "vscode") echo "# VS Code Extensions" >> "$output_file" ;;
            esac
            
            echo "$current_section" >> "$output_file"
        fi
    done
}

# Compare files and show differences
show_differences() {
    local existing_file="$1"
    local new_file="$2"
    
    if [[ -f "$existing_file" ]]; then
        log_info "Changes to be made:"
        echo ""
        
        # Show additions
        local additions=$(comm -13 <(extract_packages "$existing_file" | sort) <(extract_packages "$new_file" | sort))
        if [[ -n "$additions" ]]; then
            echo -e "${GREEN}Additions:${NC}"
            echo "$additions" | sed 's/^/  + /'
            echo ""
        fi
        
        # Show removals  
        local removals=$(comm -23 <(extract_packages "$existing_file" | sort) <(extract_packages "$new_file" | sort))
        if [[ -n "$removals" ]]; then
            echo -e "${RED}Removals:${NC}"
            echo "$removals" | sed 's/^/  - /'
            echo ""
        fi
        
        if [[ -z "$additions" && -z "$removals" ]]; then
            log_success "No changes needed - Brewfile is up to date!"
        fi
    else
        log_info "Creating new Brewfile with $(wc -l < "$new_file") entries"
    fi
}

# Extract package names from Brewfile for comparison
extract_packages() {
    local file="$1"
    grep -E '^(tap|brew|cask|mas|whalebrew|vscode) ' "$file" 2>/dev/null | sed 's/[[:space:]]*#.*//' || true
}

# Main execution
main() {
    log_info "Starting Brewfile update process..."
    verbose_log "Brewfile location: $BREWFILE"
    
    # Check if brew is available
    if ! command -v brew >/dev/null 2>&1; then
        log_error "Homebrew not found. Please install Homebrew first."
        exit 1
    fi
    
    # Generate current state
    local current_brewfile=$(generate_current_brewfile)
    local temp_output=$(mktemp)
    
    # Create backup
    if [[ ! "$DRY_RUN" == "true" ]]; then
        create_backup
    fi
    
    # Merge configurations
    merge_sections "$BREWFILE" "$current_brewfile" "$temp_output"
    
    # Show differences
    show_differences "$BREWFILE" "$temp_output"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Dry run mode - no changes made"
        log_info "Generated Brewfile preview:"
        echo "----------------------------------------"
        cat "$temp_output"
        echo "----------------------------------------"
    else
        # Create directory if it doesn't exist
        mkdir -p "$(dirname "$BREWFILE")"
        
        # Update the Brewfile
        mv "$temp_output" "$BREWFILE"
        log_success "Brewfile updated successfully: $BREWFILE"
        
        # Show summary
        local total_entries=$(extract_packages "$BREWFILE" | wc -l | tr -d ' ')
        log_success "Total entries: $total_entries"
    fi
    
    # Cleanup
    rm -f "$current_brewfile" "$temp_output" 2>/dev/null || true
}

# Run main function
main "$@"